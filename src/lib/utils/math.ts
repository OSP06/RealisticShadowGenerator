/**
 * Math utility functions for shadow generation
 */

/**
 * Clamp a value between min and max
 */
export function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

/**
 * Convert degrees to radians
 */
export function degreesToRadians(degrees: number): number {
  return (degrees * Math.PI) / 180;
}

/**
 * Convert radians to degrees
 */
export function radiansToDegrees(radians: number): number {
  return (radians * 180) / Math.PI;
}

/**
 * Linear interpolation between two values
 */
export function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

/**
 * Normalize a value from [min, max] to [0, 1]
 */
export function normalize(value: number, min: number, max: number): number {
  if (max === min) return 0;
  return (value - min) / (max - min);
}

/**
 * Exponential falloff function for shadow opacity
 * Returns opacity value between 0 and 1
 */
export function exponentialFalloff(
  distance: number,
  maxOpacity: number,
  falloffRate: number,
  maxDistance: number
): number {
  const normalizedDist = normalize(distance, 0, maxDistance);
  const opacity = maxOpacity * Math.exp(-falloffRate * normalizedDist);
  return clamp(opacity, 0, 1);
}

/**
 * Calculate Euclidean distance between two points
 */
export function distance(x1: number, y1: number, x2: number, y2: number): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Calculate distance squared (faster when you don't need the actual distance)
 */
export function distanceSquared(x1: number, y1: number, x2: number, y2: number): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
